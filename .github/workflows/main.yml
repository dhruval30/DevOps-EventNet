name: CI-CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  GAR_REPO: ${{ secrets.GAR_REPO }}
  GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}

jobs:
  # -------------------------------------------------------
  # 1) Kick off Jenkins pipeline (unit + integration + E2E + ZAP)
  # -------------------------------------------------------
  run-jenkins-pipeline:
    runs-on: ubuntu-latest
    outputs:
      result: ${{ steps.jenkins-status.outputs.result }}
    steps:
      - name: Trigger Jenkins build
        id: trigger
        run: |
          # Start the Jenkins job and capture queue URL
          QUEUE_URL=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}" \
            -X POST "https://58a340d6848f.ngrok-free.app/job/EventNet/build?token=${{ secrets.JENKINS_BUILD_TOKEN }}" \
            -D - | grep -i Location | awk '{print $2}' | tr -d '\r')
          echo "queue_url=$QUEUE_URL" >> $GITHUB_OUTPUT

      - name: Wait for Jenkins to finish
        id: jenkins-status
        run: |
          echo "Waiting for Jenkins job to complete..."
          while true; do
            BUILD_JSON=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}" \
              https://58a340d6848f.ngrok-free.app/job/EventNet/lastBuild/api/json)
            RESULT=$(echo "$BUILD_JSON" | grep -o '"result":"[^"]*"' | cut -d'"' -f4)
            if [ "$RESULT" != "null" ]; then
              echo "result=$RESULT" >> $GITHUB_OUTPUT
              [ "$RESULT" = "SUCCESS" ] && exit 0 || exit 1
            fi
            sleep 20
          done

  # -------------------------------------------------------
  # 2) Build & push images only if Jenkins succeeded
  # -------------------------------------------------------
  build-and-push:
    needs: run-jenkins-pipeline
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet

      - name: Build & push backend
        run: |
          SERVER_IMAGE="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPO }}/server:${{ github.sha }}"
          docker build -t $SERVER_IMAGE -f server/Dockerfile server
          docker push $SERVER_IMAGE
          echo "SERVER_IMAGE=$SERVER_IMAGE" >> $GITHUB_ENV

      - name: Build & push frontend
        run: |
          CLIENT_IMAGE="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPO }}/client:${{ github.sha }}"
          docker build -t $CLIENT_IMAGE -f client/Dockerfile client
          docker push $CLIENT_IMAGE
          echo "CLIENT_IMAGE=$CLIENT_IMAGE" >> $GITHUB_ENV

  # -------------------------------------------------------
  # 3) Deploy to GKE
  # -------------------------------------------------------
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure kubectl for GKE
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER }} \
            --zone ${{ secrets.GKE_ZONE }} \
            --project ${{ env.GCP_PROJECT_ID }}

      - name: Deploy new images
        run: |
          kubectl set image deployment/server server=$SERVER_IMAGE -n eventnet
          kubectl set image deployment/client client=$CLIENT_IMAGE -n eventnet
